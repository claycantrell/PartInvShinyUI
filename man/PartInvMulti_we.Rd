% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PartInv.R
\name{PartInvMulti_we}
\alias{PartInvMulti_we}
\alias{PartInv}
\title{Evaluate selection accuracy based on the MCAA Framework}
\usage{
PartInvMulti_we(
  propsel,
  cut_z = NULL,
  weights_item = NULL,
  weights_latent = NULL,
  kappa_r = NULL,
  kappa_f = kappa_r,
  alpha_r,
  alpha_f = alpha_r,
  phi_r = NULL,
  phi_f = phi_r,
  psi_r,
  psi_f = psi_r,
  lambda_r,
  lambda_f = lambda_r,
  tau_r = NULL,
  tau_f = tau_r,
  nu_r,
  nu_f = nu_r,
  Theta_r,
  Theta_f = Theta_r,
  pmix_ref = 0.5,
  plot_contour = TRUE,
  show_mi_result = FALSE,
  labels = c("Reference", "Focal"),
  ...
)

PartInv(
  propsel,
  cut_z = NULL,
  weights_item = NULL,
  weights_latent = NULL,
  kappa_r = NULL,
  kappa_f = kappa_r,
  alpha_r,
  alpha_f = alpha_r,
  phi_r = NULL,
  phi_f = phi_r,
  psi_r,
  psi_f = psi_r,
  lambda_r,
  lambda_f = lambda_r,
  tau_r = NULL,
  tau_f = tau_r,
  nu_r,
  nu_f = nu_r,
  Theta_r,
  Theta_f = Theta_r,
  pmix_ref = 0.5,
  plot_contour = TRUE,
  show_mi_result = FALSE,
  labels = c("Reference", "Focal"),
  ...
)
}
\arguments{
\item{propsel}{proportion of selection. If missing, computed using \code{cut_z}.}

\item{cut_z}{pre-specified cutoff score on the observed composite. This
argument is ignored when \code{propsel} has input.}

\item{weights_item}{a vector of item weights}

\item{weights_latent}{a vector of latent factor weights}

\item{alpha_r}{a vector of latent factor means for the reference group.}

\item{alpha_f}{(optional) a vector of latent factor means for the focal group;
if no input, set equal to alpha_r.}

\item{phi_r, phi_f, tau_r, tau_f, kappa_r, kappa_f}{deprecated; included
only for backward compatibility.}

\item{psi_r}{a matrix of latent factor variance-covariances for the
reference group.}

\item{psi_f}{(optional) a matrix of latent factor variance-covariances for
the focal group; if no input, set equal to psi_r.}

\item{lambda_r}{a matrix of factor loadings for the reference group.}

\item{lambda_f}{(optional) a matrix of factor loadings for the focal group;
if no input, set equal to lambda_r.}

\item{nu_r}{a matrix of measurement intercepts for the reference group.}

\item{nu_f}{(optional) a matrix of measurement intercepts for the focal group;
if no input, set equal to nu_r.}

\item{Theta_r}{a matrix of the unique factor variances and covariances
for the reference group.}

\item{Theta_f}{(optional) a matrix of the unique factor variances and
covariances for the focal group; if no input, set equal to Theta_r.}

\item{pmix_ref}{Proportion of the reference group;
default to 0.5 (i.e., two populations have equal size).}

\item{plot_contour}{logical; whether the contour of the two populations
should be plotted; default to TRUE.}

\item{show_mi_result}{(Not in use) If \code{TRUE}, perform selection accuracy analysis
for both the input parameters and the implied
parameters based on a strict invariance model, with
common parameter values as weighted averages of
the input values using \code{pmix_ref}.}

\item{labels}{a character vector with two elements to label the reference
and the focal group on the graph.}

\item{...}{other arguments passed to the \code{\link[graphics]{contour}}
function.}
}
\value{
The output will be a list of four elements and a plot if
\code{plot_contour == TRUE}:
\enumerate{
\item propsel: echo the same argument as input.
\item cutpt_xi: cut point on the latent scale (xi).
\item cutpt_z: cut point on the observed scale (Z).
\item summary: A 8 x 3 table, with columns representing the reference,
the focal, and the expected results if the latent distribution of
focal group matches the reference group. The rows represent
probabilities of true positive (A), false positive (B),
true negative (C), false negative (D); proportion selected,
success ratio, sensitivity, and specificity.
}
}
\description{
\code{PartInv, PartInvMulti_we} evaluate partial measurement invariance using
an extension of Millsap & Kwok's (2004) approach
}
\examples{
# Single dimension
PartInv(propsel = .10,
        weights_item = c(1, 0.9, 0.8, 1),
        weights_latent = 1,
        alpha_r = 0.5,
        alpha_f = 0,
        psi_r = 1,
        lambda_r = c(.3, .5, .9, .7),
        nu_r = c(.225, .025, .010, .240),
        nu_f = c(.225, -.05, .240, -.025),
        Theta_r = diag(.96, 4),
        labels = c("Female", "Male"))
# multiple dimensions
lambda_matrix <- matrix(0,nrow = 5, ncol = 2)
lambda_matrix[1:2, 1] <- c(.322, .655)
lambda_matrix[3:5, 2] <- c(.398, .745, .543)
PartInv(propsel = .05,
        weights_latent = c(0.5, 0.5),
        alpha_r = c(0, 0),
        alpha_f = c(-0.3, 0.1),
        psi_r = matrix(c(1, 0.5, 0.5, 1), nrow = 2),
        lambda_r = lambda_matrix,
        nu_r = c(.225, .025, .010, .240, .125),
        nu_f = c(.225, -.05, .240, -.025, .125),
        Theta_r = diag(1, 5),
        Theta_f = c(1, .95, .80, .75, 1))
PartInvMulti_we(propsel = .10,
                weights_item = c(1/3, 1/3, 1/3, 1/3),
                weights_latent = 1,
                alpha_r = 0.5,
                alpha_f = 0,
                psi_r = 1,
                lambda_r = c(.3, .5, .9, .7),
                nu_r = c(.225, .025, .010, .240),
                nu_f = c(.225, -.05, .240, -.025),
                Theta_r = diag(.96, 4),
                labels = c("female", "male"))
}
